<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Валентинка</title>
  <link href="https://fonts.googleapis.com/css2?family=Marck+Script&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; font-family: "Marck Script", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif; }
    body {
      display: flex; align-items: center; justify-content: center;
      background: radial-gradient(circle at top, #ffe6f2 0%, #ffc2e0 35%, #ff9ac4 70%, #ff7aa8 100%);
      color: #4a154b; overflow: hidden;
    }

    .valentine-container {
      position: relative; width: 100%; max-width: 480px; height: 600px;
      padding: 24px 20px 32px; border-radius: 24px;
      background: rgba(255,255,255,0.9); box-shadow: 0 18px 45px rgba(255,79,152,0.35);
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start; text-align: center; overflow: hidden;
    }

    .question-image { max-width: 90%; width: auto; height: auto; margin-top: -35px; margin-bottom: -35px; filter: drop-shadow(0 1px 2px rgba(52,46,49,0.7)); border-radius: 12px; }

    .hero-animation { max-width: 220px; width: 70%; border-radius: 24px; filter: drop-shadow(0 10px 24px rgba(255,105,180,0.7)); margin-top: -40px;
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, rgba(0,0,0,1) 18%, rgba(0,0,0,1) 82%, transparent 100%);
      mask-image: linear-gradient(to bottom, transparent 0%, rgba(0,0,0,1) 18%, rgba(0,0,0,1) 82%, transparent 100%);
    }

    .buttons { margin-top: -15px; display: flex; gap: 25px; justify-content: center; position: relative; width: 80%; }

    button {
      position: relative; width: 180px; height: 180px; border: none; font-size: 0; font-weight: 700; cursor: pointer;
      transition: transform 0.15s ease; outline: none; white-space: nowrap; user-select: none;
      background-color: transparent; background-repeat: no-repeat; background-position: center; background-size: contain;
      z-index: 1; filter: drop-shadow(0 4px 12px rgba(244,175,202,0.7));
    }

    button:active { transform: scale(0.96) translateY(1px); }

    .btn-yes { color: #fff; background-image: url("yes.png"); transform-origin: center center; animation: heartbeatButton 1.9s ease-in-out infinite; }
    .btn-yes:hover { filter: drop-shadow(0 12px 26px rgba(244,175,202,0.9)); }

    .btn-no { color: #fff; position: relative; transform-origin: center center; background-image: url("no.png"); }

    .hearts-container { pointer-events: none; position: absolute; inset: 0; overflow: visible; }
    .heart-float { position: absolute; font-size: 18px; color: #ff1100; opacity: 0; animation: floatUp 1.8s ease-out forwards; }

    @keyframes floatUp {
      0% { opacity: 0; transform: translateY(10px) scale(0.6); }
      20% { opacity: 1; }
      100% { opacity: 0; transform: translateY(-140px) scale(1.4); }
    }

    @keyframes heartbeatButton {
      0% { transform: scale(1); } 8% { transform: scale(1.18); } 18% { transform: scale(1); } 26% { transform: scale(1.16); } 36% { transform: scale(1); } 100% { transform: scale(1); }
    }

    .final-screen { position: absolute; inset: 0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:24px; background:transparent; text-align:center; pointer-events:none; }
    .final-heart { width:390px; height:auto; filter:drop-shadow(0 0 18px rgba(255,105,180,0.8)); margin-bottom:-20px; margin-top:-70px; margin-left:-45px; }
    .final-image { max-width:310px; width:80%; filter:drop-shadow(0 2px 4px rgba(244,175,202,0.95)); }
    .hidden { display: none !important; }

    @media (max-width:480px) {
      .valentine-container { max-width:92%; padding:20px 16px 26px; }
      button { width:140px; height:140px; margin-bottom:20px; }
      .buttons { gap:12px; }
      .hero-animation { margin-top:-15px; max-width:60%; clip-path: inset(10% 0 0 0); }
      .question-image { max-width:105%; margin-top:-10px; margin-bottom:-20px; }
    }
  </style>
</head>
<body>
  <main class="valentine-container">
    <div class="hearts-container" id="heartsContainer"></div>
    <video class="hero-animation" id="heroAnimation" src="q.webm" autoplay loop muted playsinline></video>
    <img src="my.png" alt="Будешь моей валентинкой?" class="question-image" id="questionImage" />
    <div class="buttons" id="buttonsContainer">
      <button class="btn-yes" id="yesButton">ДА</button>
      <button class="btn-no" id="noButton">НЕТ</button>
    </div>

    <div class="final-screen hidden" id="finalScreen">
      <img src="love.webp" alt="Я люблю тебя" class="final-heart" />
      <img src="ilu.png" alt="Я люблю тебя" class="final-image" />
    </div>
  </main>

  <script>
    // Элементы
    const yesButton = document.getElementById("yesButton");
    const noButton = document.getElementById("noButton");
    const heartsContainer = document.getElementById("heartsContainer");
    const buttonsContainer = document.getElementById("buttonsContainer");
    const heroAnimation = document.getElementById("heroAnimation");
    const finalScreen = document.getElementById("finalScreen");
    const questionImage = document.getElementById("questionImage");

    const ESCAPE_DISTANCE = 220; // минимальное расстояние от указателя до центра НЕТ, чтобы не "дотянулись"

   // Создаёт плавающее сердечко по случайным координатам по всей белой карточке
function createFloatingHeart() {
  const heart = document.createElement("div");
  heart.className = "heart-float";
  heart.textContent = "❤";

  // случайный размер (px)
  const size = 14 + Math.floor(Math.random() * 28); // от ~14px до ~41px
  heart.style.fontSize = size + "px";

  // размещаем по всему контейнеру .valentine-container (heartsContainer имеет inset:0)
  // оставим небольшой отступ по краям, чтобы не обрезать
  const leftPct = 3 + Math.random() * 94; // 3% ... 97%
  const topPct  = 3 + Math.random() * 94; // 3% ... 97%
  heart.style.left = leftPct + "%";
  heart.style.top  = topPct + "%";

  // чуть-чуть варьируем длительность и старт (чтобы выглядело естественнее)
  const dur = 1400 + Math.random() * 1400; // 1400–2800 ms
  const delay = Math.random() * 300; // 0–300 ms
  heart.style.animationDuration = dur + "ms";
  heart.style.animationDelay = delay + "ms";

  heartsContainer.appendChild(heart);

  // удаляем после окончания анимации
  heart.addEventListener("animationend", () => heart.remove());
}

// Взрыв сердечек (можно оставить количество и интервал как хотите)
function triggerHeartsBurst() {
  for (let i = 0; i < 14; i++) {
    setTimeout(createFloatingHeart, i * 90);
  }
}


    yesButton.addEventListener("click", () => {
      triggerHeartsBurst();
      buttonsContainer.classList.add("hidden");
      questionImage.classList.add("hidden");
      if (heroAnimation) heroAnimation.classList.add("hidden");
      if (finalScreen) finalScreen.classList.remove("hidden");
    });

    // Утилиты для проверки пересечения прямоугольников
    function rectsOverlap(aLeft, aTop, aW, aH, bRect, padding = 6) {
      const aRight = aLeft + aW;
      const aBottom = aTop + aH;
      const bLeft = bRect.left - padding;
      const bTop = bRect.top - padding;
      const bRight = bRect.right + padding;
      const bBottom = bRect.bottom + padding;
      return !(aRight < bLeft || aLeft > bRight || aBottom < bTop || aTop > bBottom);
    }

    /**
     * Перемещает кнопку "НЕТ" в случайную позицию, не пересекающую кнопку "ДА"
     */
    function moveNoButtonAway(pointerX, pointerY) {
      const rect = noButton.getBoundingClientRect();
      const btnWidth = rect.width;
      const btnHeight = rect.height;

      // Переключаемся на fixed при первом перемещении (чтобы работа была предсказуемой)
      if (getComputedStyle(noButton).position !== "fixed") {
        noButton.style.position = "fixed";
        noButton.style.left = rect.left + "px";
        noButton.style.top = rect.top + "px";
      }

      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const padding = 8;
      const minX = padding;
      const maxX = viewportWidth - btnWidth - padding;
      const minY = padding;
      const maxY = viewportHeight - btnHeight - padding;

      // Данные кнопки YES (в системе координат окна)
      const yesRect = yesButton.getBoundingClientRect();

      const maxAttempts = 50;
      let newLeft = rect.left;
      let newTop = rect.top;
      let found = false;

      for (let i = 0; i < maxAttempts; i++) {
        const candidateLeft = Math.random() * (maxX - minX) + minX;
        const candidateTop = Math.random() * (maxY - minY) + minY;

        // проверим расстояние от указателя (чтобы не смещать странно близко)
        const candidateCenterX = candidateLeft + btnWidth / 2;
        const candidateCenterY = candidateTop + btnHeight / 2;
        const distance = Math.hypot(candidateCenterX - pointerX, candidateCenterY - pointerY);

        // не допускаем пересечения с кнопкой "ДА"
        const overlapsYes = rectsOverlap(candidateLeft, candidateTop, btnWidth, btnHeight, yesRect, /*padding=*/12);

        if (!overlapsYes && distance > ESCAPE_DISTANCE * 1.05) {
          newLeft = candidateLeft;
          newTop = candidateTop;
          found = true;
          break;
        }
      }

      // если не нашли полностью свободного места — поместим кнопку на противоположную от указателя сторону,
      // но тоже стараясь не пересекаться с YES
      if (!found) {
        // центр указателя по горизонтали: если левее центра — отодвинем вправо, иначе влево
        const preferLeft = pointerX > viewportWidth / 2 ? minX : maxX;
        const preferTop = pointerY > viewportHeight / 2 ? minY : maxY;
        // попробуем разместить в углу (или рядом с ним)
        let candidateLeft = preferLeft;
        let candidateTop = preferTop;
        // если всё ещё пересекает — сдвинем по вертикали на шаг
        for (let s = 0; s < 10; s++) {
          if (!rectsOverlap(candidateLeft, candidateTop, btnWidth, btnHeight, yesRect, 12)) {
            newLeft = candidateLeft;
            newTop = candidateTop;
            found = true;
            break;
          }
          candidateLeft = Math.min(maxX, Math.max(minX, candidateLeft + (s % 2 === 0 ? 30 : -30)));
          candidateTop = Math.min(maxY, Math.max(minY, candidateTop + (s % 2 === 0 ? 30 : -30)));
        }
        // если всё ещё не нашли — оставляем текущую позицию (чтобы не запутать пользователя)
      }

      noButton.style.left = Math.round(newLeft) + "px";
      noButton.style.top = Math.round(newTop) + "px";
      noButton.style.transform = "translate(0, 0)";
    }

    function handlePointerMove(pointerX, pointerY) {
      const rect = noButton.getBoundingClientRect();
      const btnCenterX = rect.left + rect.width / 2;
      const btnCenterY = rect.top + rect.height / 2;
      const distance = Math.hypot(pointerX - btnCenterX, pointerY - btnCenterY);

      if (distance < ESCAPE_DISTANCE) {
        moveNoButtonAway(pointerX, pointerY);
      }
    }

    // мышь
    document.addEventListener("mousemove", (event) => {
      handlePointerMove(event.clientX, event.clientY);
    });

    // касания (мобильные)
    document.addEventListener("touchmove", (event) => {
      if (event.touches && event.touches.length > 0) {
        const touch = event.touches[0];
        handlePointerMove(touch.clientX, touch.clientY);
      }
    }, { passive: true });

    // защита: если курсор на кнопке — сразу убегаем
    noButton.addEventListener("mouseenter", (event) => {
      moveNoButtonAway(event.clientX, event.clientY);
    });

    noButton.addEventListener("mousedown", (event) => {
      event.preventDefault();
      moveNoButtonAway(event.clientX, event.clientY);
    });

    // клик (например клавиатурный) — блокируем "НЕТ" и убегаем
    noButton.addEventListener("click", (event) => {
      event.preventDefault();
      const rect = noButton.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      moveNoButtonAway(centerX, centerY);
    });

    // Дополнительно: при изменении размера окна можно скорректировать позицию, чтобы НЕ оказаться поверх кнопки YES
    window.addEventListener("resize", () => {
      // Если кнопки уже в position:fixed — убедимся, что НЕТ не пересекает ДА; если пересекает, сдвинем
      if (getComputedStyle(noButton).position === "fixed") {
        const nbRect = noButton.getBoundingClientRect();
        const yesRect = yesButton.getBoundingClientRect();
        if (rectsOverlap(nbRect.left, nbRect.top, nbRect.width, nbRect.height, yesRect, 12)) {
          // отправим кнопку НЕТ в безопасное место (в центр правого/левого края)
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const btnWidth = nbRect.width;
          const btnHeight = nbRect.height;
          const candidateLeft = viewportWidth - btnWidth - 16;
          const candidateTop = Math.min(Math.max(16, nbRect.top), viewportHeight - btnHeight - 16);
          noButton.style.left = candidateLeft + "px";
          noButton.style.top = candidateTop + "px";
        }
      }
    });

  </script>
</body>
</html>
